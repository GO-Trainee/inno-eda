# InnoEda: Платформа для заказа и доставки еды (Финальная Документация)

## Содержание
1.  [Обзор](#1-обзор)
    1. [Цели проекта](#11-цели-проекта)
    2. [Основные возможности](#12-основные-возможности)
    3. [Роли пользователей](#13-роли-пользователей)
    4. [Конфиденциальность](#14-конфиденциальность)
2.  [Архитектура микросервисов](#2-архитектура-микросервисов)
    1. [Перечень микросервисов](#21-перечень-микросервисов)
    2. [Общая диаграмма архитектуры](#22-общая-диаграмма-архитектуры)
3.  [Функциональные Требования (FR)](#3-функциональные-требования-fr)
    1. [Auth Service](#31-auth-service)
    2. [User (Profile) Service](#32-user-profile-service)
    3. [Gateway Service](#33-gateway-service)
    4. [Delivery Service](#34-delivery-service)
    5. [Order Service](#35-order-service)
    6. [Payment Service](#36-payment-service)
    7. [Product Service](#37-product-service)
    8. [Bonus Service](#38-bonus-service)
    9. [Notification Service](#39-notification-service)
    10. [Support Service](#310-support-service)
    11. [Media Service](#311-media-service)
    12. [Provider Service](#312-provider-service)
    13. [Report Service](#313-report-service)
    14. [Analytic Service](#314-analytic-service)
    15. [Recommender Service](#315-recommender-service)
4.  [Нефункциональные Требования (NFR)](#4-нефункциональные-требования-nfr)
    1. [Общие NFR](#41-общие-nfr)
    2. [NFR для каждого микросервиса](#42-nfr-для-каждого-микросервиса)
        *   [Auth Service NFR](#auth-service-nfr)
        *   [User (Profile) Service NFR](#user-profile-service-nfr)
        *   [Gateway Service NFR](#gateway-service-nfr)
        *   [Delivery Service NFR](#delivery-service-nfr)
        *   [Order Service NFR](#order-service-nfr)
        *   [Payment Service NFR](#payment-service-nfr)
        *   [Product Service NFR](#product-service-nfr)
        *   [Bonus Service NFR](#bonus-service-nfr)
        *   [Notification Service NFR](#notification-service-nfr)
        *   [Support Service NFR](#support-service-nfr)
        *   [Media Service NFR](#media-service-nfr)
        *   [Provider Service NFR](#provider-service-nfr)
        *   [Report Service NFR](#report-service-nfr)
        *   [Analytic Service NFR](#analytic-service-nfr)
        *   [Recommender Service NFR](#recommender-service-nfr)
5.  [Взаимодействие между сервисами](#5-взаимодействие-между-сервисами)
6.  [Технические требования и Руководства по разработке](#6-технические-требования-и-руководства-по-разработке)

---

## 1. Обзор

InnoEda — это облачная экосистема для заказа и доставки еды, объединяющая клиентов, курьеров и партнеров-ресторанов. Платформа организована на основе чистой микросервисной архитектуры.

### 1.1. Цели проекта
Создать масштабируемую, отказоустойчивую и удобную платформу для заказа еды, обеспечивающую эффективное взаимодействие всех участников процесса: клиентов, ресторанов, курьеров и администрации платформы.

### 1.2. Основные возможности
*   **Поиск и фильтрация:** Пользователи могут просматривать широкий выбор ресторанов и блюд, фильтровать по типу кухни, ценовому диапазону, времени доставки, рейтингам.
*   **Размещение и оплата заказа:** Пользователи добавляют товары в корзину, применяют промокоды или бонусы и безопасно оплачивают заказы различными способами.
*   **Отслеживание курьера в реальном времени:** После подтверждения заказа клиенты видят местоположение курьера на карте, получают предполагаемое время прибытия и обновления статуса.
*   **Интеграция с поставщиками:** InnoEda напрямую подключается к системам ресторанов, обеспечивая актуальность меню, цен и остатков.
*   **Рекомендации и отзывы:** Система предлагает блюда на основе истории заказов и популярных трендов. Пользователи могут оставлять оценки и отзывы.
*   **Программа лояльности и скидки:** Динамические скидки, бонусные баллы и специальные предложения.

### 1.3. Роли пользователей
Платформа поддерживает следующие основные роли:
*   **Клиент (Customer):** Заказывает еду, отслеживает доставку, управляет профилем и кошельком.
*   **Курьер (Courier):** Принимает и выполняет заказы на доставку, обновляет статусы.
*   **Администратор ресторана/поставщика (Restaurant/Provider Admin):** Управляет информацией о заведении, меню, заказами.
*   **Администратор платформы (Platform Admin):** Управляет работой платформы, пользователями, настройками.
*   **Аналитик (Analyst):** Доступ к агрегированным данным и отчетам для анализа.
*   **Агент поддержки (Support Agent):** Обрабатывает запросы и жалобы пользователей.

### 1.4. Конфиденциальность
**Важно:** Все репозитории, созданные в рамках этого проекта, должны оставаться **приватными**. Они являются частью соглашения о неразглашении (NDA) и **никогда** не должны становиться публичными.

---

## 2. Архитектура микросервисов

### 2.1. Перечень микросервисов
Система состоит из 15 ключевых микросервисов:

| №  | Сервис                     | Язык разработки | Описание                                                                                                                        |
|----|----------------------------|-----------------|---------------------------------------------------------------------------------------------------------------------------------|
| 1  | **Auth Service**           | Go              | Централизованная аутентификация и авторизация для всех ролей, управление JWT.                                                   |
| 2  | **User (Profile) Service** | Go              | Управление профилями пользователей, персональной информацией, настройками и кошельками.                                         |
| 3  | **Gateway Service**        | Go              | Единая точка входа для клиентских запросов (REST, GraphQL, WebSocket), маршрутизация, валидация JWT, преобразование протоколов. |
| 4  | **Delivery Service**       | Go              | Управление созданием заказов, назначением курьеров, отслеживанием доставки в реальном времени и обновлением статусов.           |
| 5  | **Order Service**          | Go              | Оркестрация заказов, управление жизненным циклом заказа, статусами, историей.                                                   |
| 6  | **Payment Service**        | Go              | Обработка платежей, транзакций, возвратов, взаимодействие с платежными шлюзами и системой бонусов.                              |
| 7  | **Product Service**        | Go              | Управление каталогом продуктов, меню, доступностью товаров, ценами, поиск и фильтрация.                                         |
| 8  | **Bonus Service**          | Go              | Управление программами лояльности, начислением и списанием бонусов, историей бонусных операций.                                 |
| 9  | **Notification Service**   | Go              | Отправка уведомлений пользователям и курьерам (email, SMS, push, WebSocket) на основе событий из других сервисов.               |
| 10 | **Support Service**        | Go              | Управление обращениями в поддержку, тикет-система, онлайн-чат.                                                                  |
| 11 | **Media Service**          | Go              | Обработка, хранение и доставка медиафайлов (фотографии блюд, логотипы, аватары, чеки).                                          |
| 12 | **Provider Service**       | Go              | Управление информацией о поставщиках (рестораны, магазины), их меню и доступностью.                                             |
| 13 | **Report Service**         | Go              | Управление жалобами пользователей на качество еды, сервис и т.д., включая медиа-вложения.                                       |
| 14 | **Analytic Service**       | Go              | Сбор, агрегация и анализ данных со всей платформы, формирование отчетов и метрик.                                               |
| 15 | **Recommender Service**    | Go              | Предоставление персонализированных рекомендаций продуктов и заказов на основе данных аналитики и предпочтений пользователя.     |

### 2.2. Общая диаграмма архитектуры
#### Диграмма
https://drive.google.com/file/d/18wuiMAof6E0sXsQbAXggintkeOn64gYP/view

#### v1 - не была записана

#### 04.04.2025 arch v2
https://drive.google.com/file/d/1Oqp5ELis5kokVyHVijfXc_HXZO5mEMdD/view

#### 08.04.2025 arch v3 
https://drive.google.com/file/d/1oERlIm33lxh9q-QgrqVzZwWa3dkn0qV2/view

#### 15.04.2025 arch v4
https://drive.google.com/file/d/1afzeHXgHrttk5IboypeGUOVjVWzhEKSm/view

#### 22.04.2025 arch v5
https://drive.google.com/file/d/1cZnC7dgqTMzcJc8TG8A97pE7oYmwnivs/view
---

## 3. Функциональные Требования (FR)

### 3.1. Auth Service
*   **Управление ролями:** Выпуск JWT-токенов, содержащих список ролей пользователя (например, `["Customer", "Courier", "Restaurant Admin", "Platform Admin", "Analyst", "Support Agent"]`). Пользователи могут иметь несколько ролей.
*   **Аутентификация:** Обработка запросов на вход (signin) и выход (logout) для всех типов пользователей. Проверка учетных данных.
*   **Управление учетными данными:**
    *   Безопасное хранение и шифрование учетных данных пользователей (например, паролей).
    *   Функционал восстановления и сброса пароля с верификацией по email.
*   **Управление токенами:**
    *   Генерация пар токенов **доступа (access)** и **обновления (refresh)** для аутентифицированных пользователей.
    *   Поддержка обновления пары токенов для сохранения сессии.
    *   Токены доступа подписываются с использованием асимметричного шифрования (например, RSA).
    *   Валидация токенов (подпись, срок действия, отзыв) выполняется локально сервисами.
*   **Контроль доступа:** Предоставление информации о ролях при валидации токена. Сервисы применяют контроль доступа на основе ролей.
*   **API эндпоинты (REST):**
    *   `POST /auth/signup` - Регистрация нового пользователя.
    *   `POST /auth/signin` - Аутентификация и выпуск JWT.
    *   `POST /auth/signout` - Выход из системы и инвалидация токена (добавление в черный список).
    *   `POST /auth/refresh` - Обновление пары токенов.
    *   `POST /auth/recover-password` - Запрос на восстановление пароля.
    *   `POST /auth/reset-password` - Установка нового пароля.

### 3.2. User (Profile) Service
*   **Управление профилем:** CRUD операции для профилей пользователей: имя, телефон, email, аватар (через Media Service).
*   **Управление кошельком:**
    *   Типы кошельков: `personal`, `family`.
    *   Семейные кошельки могут иметь несколько пользователей, управляемых владельцем кошелька.
    *   Просмотр баланса и истории транзакций.
*   **Настройки пользователя:** Управление предпочтениями уведомлений, сохраненными адресами и т.д.
*   **Верификация:** (Опционально) Хранение статуса верификации для определенных ролей (например, курьеров).
*   **API эндпоинты (REST):**
    *   `GET /users/me/profile` - Получение данных профиля текущего пользователя.
    *   `PUT /users/me/profile` - Обновление данных профиля текущего пользователя.
    *   `POST /users/me/wallets` - Создание нового кошелька.
    *   `GET /users/me/wallets` - Получение списка кошельков пользователя.
    *   `GET /users/me/wallets/{wallet_id}/transactions` - Просмотр транзакций кошелька.
    *   `PUT /users/me/preferences` - Обновление настроек пользователя.

### 3.3. Gateway Service
*   **Централизованная точка входа:** Обработка всех внешних клиентских запросов (веб, мобильные приложения).
*   **Маршрутизация запросов:** Направление входящих HTTP/WebSocket запросов к соответствующим микросервисам на основе пути и заголовков.
    *   `/auth/**` → Auth Service
    *   `/users/**` → User Service
    *   `/orders/**` → Order Service (или Delivery Service в зависимости от эндпоинта)
    *   `/delivery/**` → Delivery Service
    *   `/products/**` → Product Service
    *   `/support/**` → Support Service
    *   ... и так далее для остальных сервисов.
*   **Преобразование протоколов:** Трансляция REST/JSON в gRPC/protobuf и обратно. Обработка преобразований WebSocket в gRPC streaming.
*   **Безопасность:** Валидация JWT токенов (локально, с использованием публичного ключа Auth Service).
*   **Агрегация данных (GraphQL):**
    *   Предоставление GraphQL эндпоинта для агрегированных запросов (например, `query { me { profile, orders, wallet } }`).
    *   Мутации для выполнения нескольких операций (например, `mutation { createOrder(...), updateProfile(...) }`).
*   **WebSocket шлюз:** Поддержка WebSocket соединений для уведомлений в реальном времени.
    *   Каналы: `delivery_updates`, `support_updates`, `notifications`.
*   **Дополнительные функции:** Логирование запросов/ответов, трассировка, управление CORS, ограничение скорости запросов (rate limiting).

### 3.4. Delivery Service
*   **Создание заказа на доставку:**
    *   Поля заказа: точка получения, точка доставки, список блюд, предполагаемое время доставки.
    *   При размещении заказа сервис проверяет баланс кошелька через Payment Service и инициирует создание заказа.
*   **Назначение курьера:** Система назначает доступного курьера или помещает заказ в очередь ожидания.
*   **Обновление статуса доставки курьером:**
    *   Статусы: `pending_acceptance` (курьер еще не принял), `accepted` (принят курьером), `picking_up` (едет за заказом), `on_the_way` (в пути к клиенту), `delivered` (доставлен), `failed` (не удалась), `cancelled` (отменен).
*   **Отслеживание доставки клиентом:** Обновление статуса и местоположения курьера в реальном времени через WebSocket (`delivery_updates`).
*   **Обновление статуса готовности заказа поставщиком.**
*   **API эндпоинты (REST):**
    *   `POST /delivery/orders` - Создание нового заказа на доставку (может вызываться Order Service).
    *   `PUT /delivery/orders/{order_id}/status` - Обновление статуса доставки (курьером или системой).
    *   `GET /delivery/orders/{order_id}` - Получение деталей доставки.
    *   `GET /delivery/couriers/{courier_id}/location` - Получение текущего местоположения курьера (внутренний или для отслеживания).
    *   `PUT /delivery/couriers/{courier_id}/status` - Обновление статуса курьера (online, offline, on_delivery).

### 3.5. Order Service
*   **Размещение заказа клиентом:**
    *   Принятие новых заказов от клиентов, включая выбранные товары, адрес доставки, способ оплаты.
    *   Валидация деталей заказа (например, доступность товаров через Product Service, зона доставки).
*   **Управление жизненным циклом заказа:**
    *   Отслеживание статуса каждого заказа: `created` (создан), `payment_pending` (ожидает оплаты), `paid` (оплачен), `confirmed` (подтвержден рестораном), `preparing` (готовится), `ready_for_pickup` (готов к выдаче курьеру), `delivering` (доставляется), `completed` (завершен), `cancelled` (отменен), `refund_pending` (ожидает возврата), `refunded` (возвращен).
    *   Обновление статуса заказа на основе событий от других сервисов (Payment, Delivery, Provider).
*   **История заказов:** Хранение завершенных заказов для долгосрочного извлечения и отчетности. Просмотр клиентами своих прошлых заказов.
*   **Применение скидок и бонусов:** Взаимодействие с Bonus Service для валидации и применения бонусов к заказам.
*   **API эндпоинты (REST через Gateway, или gRPC для внутренних вызовов):**
    *   `POST /orders` - Создание нового заказа клиентом.
    *   `GET /orders` - Получение списка заказов клиента (с пагинацией и фильтрами).
    *   `GET /orders/{order_id}` - Получение деталей конкретного заказа.
    *   `PUT /orders/{order_id}/cancel` - Отмена заказа клиентом (если применимо по бизнес-логике).

### 3.6. Payment Service
*   **Обработка платежей:**
    *   Интеграция с внешними платежными шлюзами (например, Stripe).
    *   Поддержка различных методов оплаты (банковские карты, электронные кошельки).
*   **Управление транзакциями:**
    *   Запись полной истории транзакций со статусами: `pending`, `success`, `failed`, `refunded`.
    *   Обработка возвратов и сторнирования платежей с аудитом.
*   **Интеграция с Bonus Service:** Применение бонусных баллов/скидок во время оформления заказа. Обработка сценариев списания и возврата бонусов.
*   **Генерация счетов/чеков:** (Опционально) Создание детализированных счетов и их хранение через Media Service.
*   **API эндпоинты (gRPC для внутренних вызовов Order Service, REST через Gateway для специфичных операций):**
    *   `POST /payments/process` - Инициация процесса оплаты для заказа (вызывается Order Service).
    *   `GET /payments/orders/{order_id}/status` - Получение статуса платежа для заказа.
    *   `POST /payments/refunds` - Инициация возврата платежа.
    *   Веб-хуки от платежных систем для обновления статусов.

### 3.7. Product Service
*   **Управление каталогом:**
    *   Продукты: `productId`, название, описание, цена, теги, категория, изображение (ссылка на Media Service), доступность, статус (`draft`, `published`, `archived`, `banned`).
*   **Поиск и фильтрация:**
    *   Расширенный поиск по названию, описанию, тегам.
    *   Фильтрация по цене, категории, статусу, популярности, новизне.
*   **Управление доступностью (инвентаризация):** Отслеживание остатков товаров, синхронизация с Provider Service.
*   **Управление акциями и скидками:** Установка специальных цен, пакетных предложений.
*   **API эндпоинты (REST через Gateway, gRPC для внутренних):**
    *   `GET /products` - Получение списка продуктов с фильтрацией и пагинацией.
    *   `GET /products/{product_id}` - Получение информации о конкретном продукте.
    *   `GET /categories` - Получение списка категорий продуктов.
    *   (Внутренние gRPC) Обновление остатков, получение информации для Order Service.

### 3.8. Bonus Service
*   **Начисление бонусов:** Автоматическое начисление бонусов (баллы, скидки) за выполнение определенных действий (например, завершение заказа, участие в акции, реферальная программа).
*   **Списание (погашение) бонусов:** Расчет и применение (резервирование) скидки при запросе от Payment Service или Order Service.
*   **Баланс и история:** Пользователи могут просматривать свой текущий бонусный баланс и детализированную историю начислений и списаний.
*   **Срок действия бонусов:** Бонусы могут иметь срок действия; просроченные бонусы аннулируются.
*   **Администрирование:** (Опционально) Возможность для администраторов платформы создавать промокоды, корректировать балансы, массово начислять бонусы.
*   **API эндпоинты (gRPC для внутренних вызовов):**
    *   `ApplyBonus(orderId, userId, amount)` - Запрос на применение бонусов к заказу.
    *   `CreditBonus(userId, amount, reason, orderId)` - Начисление бонусов.
    *   `GetBalance(userId)` - Получение бонусного баланса пользователя.
    *   `GetHistory(userId)` - Получение истории бонусных операций.

### 3.9. Notification Service
*   **Прием событий:** Получение событий от других сервисов через Kafka (например, изменение статуса заказа, успешный платеж, начисление бонусов, новое сообщение в поддержке, обновление доставки).
*   **Отправка уведомлений:**
    *   Каналы: WebSocket (in-app), Push-уведомления (мобильные), Email, SMS (опционально).
    *   Использование шаблонов для сообщений.
*   **Управление предпочтениями:** Учет настроек уведомлений пользователя из User Service.
*   **История уведомлений:** Пользователи могут просматривать список своих прошлых уведомлений.
*   **Управление статусом прочтения:** Отметка уведомлений как прочитанных/непрочитанных.
*   **API эндпоинты (REST через Gateway):**
    *   `GET /notifications` - Получение списка уведомлений для текущего пользователя.
    *   `POST /notifications/{notification_id}/read` - Отметить уведомление как прочитанное.
    *   (WebSocket) Подписка на получение уведомлений в реальном времени.

### 3.10. Support Service
*   **Управление тикетами:**
    *   Клиенты могут создавать тикеты поддержки (тема, описание, приоритет, категория).
    *   Тикеты хранятся с отслеживанием статуса (`open`, `in_progress`, `resolved`, `closed`, `pending_customer_response`).
*   **Чат с поддержкой:**
    *   Реализация чата в реальном времени между клиентом и агентом поддержки через WebSocket.
    *   Возможность прикрепления файлов (через Media Service) к сообщениям в чате.
*   **База знаний/FAQ:** (Опционально) Интеграция или предоставление доступа к базе знаний.
*   **Назначение агентов:** Автоматическое или ручное назначение тикетов/чатов агентам поддержки.
*   **API эндпоинты (REST через Gateway, WebSocket):**
    *   `POST /support/tickets` - Создание нового тикета.
    *   `GET /support/tickets` - Получение списка тикетов пользователя.
    *   `GET /support/tickets/{ticket_id}` - Просмотр деталей тикета и сообщений.
    *   `POST /support/tickets/{ticket_id}/messages` - Отправка сообщения в тикет.
    *   (WebSocket) Каналы для чата поддержки: `support_chat_{user_id}`, `support_agent_pool`.

### 3.11. Media Service
*   **Загрузка медиафайлов:**
    *   Прием файлов (изображения: JPEG, PNG; документы: PDF для чеков/инвойсов).
    *   Валидация формата и размера файла.
    *   (Опционально) Сканирование на запрещенный контент.
*   **Хранение медиафайлов:** Использование объектного хранилища (например, AWS S3, MinIO).
*   **Доступ к медиафайлам:** Предоставление URL для доступа к файлам. Генерация временных подписанных URL для приватных файлов.
*   **Удаление медиафайлов:** Мягкое (пометка как удаленный) и жесткое удаление.
*   **Предотвращение дубликатов:** (Опционально) Проверка по хешу файла для предотвращения повторной загрузки идентичных файлов.
*   **API эндпоинты (gRPC для внутренних сервисов, REST через Gateway для загрузки клиентами):**
    *   `POST /media/upload` - Загрузка файла, возвращает `media_id` и URL.
    *   `GET /media/{media_id}` - Получение информации о файле или редирект на файл.
    *   (Внутренние gRPC) Загрузка, удаление, получение URL сервисами.

### 3.12. Provider Service
*   **Управление поставщиками:** Регистрация и управление профилями поставщиков (рестораны, магазины): название, адрес, описание, часы работы, зоны доставки, логотип (через Media Service).
*   **Управление меню поставщика:**
    *   Добавление, обновление, удаление блюд и продуктов в меню поставщика.
    *   Синхронизация этой информации с Product Service.
*   **Управление заказами поставщика:**
    *   Просмотр новых заказов, поступающих поставщику.
    *   Обновление статусов готовности заказов (например, `confirmed`, `preparing`, `ready_for_pickup`).
*   **API эндпоинты (REST через Gateway для административного интерфейса поставщиков, gRPC для внутренних):**
    *   `GET /provider/profile` - Получение профиля поставщика.
    *   `PUT /provider/profile` - Обновление профиля поставщика.
    *   `GET /provider/menu` - Получение меню поставщика.
    *   `POST /provider/menu/items` - Добавление нового блюда в меню.
    *   `PUT /provider/menu/items/{item_id}` - Обновление блюда.
    *   `GET /provider/orders` - Получение списка заказов для поставщика.
    *   `PUT /provider/orders/{order_id}/status` - Обновление статуса заказа поставщиком.

### 3.13. Report Service
*   **Подача жалоб/отчетов:** Пользователи могут подавать жалобы, связанные с заказом, доставкой, качеством еды, и т.д.
    *   Поля отчета: тема, описание, категория, ссылка на заказ, опциональные медиа-вложения (через Media Service).
*   **Управление статусами отчетов:** `new`, `in_review`, `resolved`, `rejected`, `closed`.
*   **Прикрепление доказательств:** Пользователи или агенты поддержки могут прикреплять файлы к отчетам.
*   **Взаимодействие со Support Service:** Отчеты могут быть эскалированы в тикеты поддержки или связаны с ними.
*   **API эндпоинты (REST через Gateway):**
    *   `POST /reports` - Создание нового отчета/жалобы.
    *   `GET /reports` - Получение списка отчетов пользователя.
    *   `GET /reports/{report_id}` - Получение деталей отчета.
    *   (Внутренние эндпоинты для Support Service для управления отчетами).

### 3.14. Analytic Service
*   **Сбор данных:** Потребление событий из Kafka от всех ключевых микросервисов (заказы, платежи, пользователи, доставки, отзывы, просмотры продуктов и т.д.).
*   **Обработка и агрегация данных:**
    *   Преобразование сырых событий в структурированные метрики.
    *   Агрегация данных по различным измерениям (время, регион, тип пользователя и т.д.).
*   **Предоставление аналитики:**
    *   Ключевые метрики: общее количество заказов, средний чек, количество новых пользователей, активные пользователи, рейтинги ресторанов/курьеров, популярные блюда.
    *   Фильтрация аналитики по периодам времени (день, неделя, месяц).
*   **Интеграция с дашбордами:** Предоставление данных для инструментов визуализации (например, Grafana, или внутренние дашборды).
*   **Экспорт данных:** (Опционально) Предоставление агрегированных данных для других сервисов (например, Recommender Service).
*   **API эндпоинты (REST через Gateway для доступа к отчетам, gRPC для внутренних):**
    *   `GET /analytics/summary` - Получение сводной аналитики.
    *   `GET /analytics/orders` - Аналитика по заказам.
    *   `GET /analytics/users` - Аналитика по пользователям.
    *   (Внутренние gRPC для Recommender Service).

### 3.15. Recommender Service
*   **Генерация рекомендаций:**
    *   На основе истории заказов пользователя, просмотренных товаров, оценок.
    *   Алгоритмы: коллаборативная фильтрация, "пользователи, купившие X, также интересовались Y", "похожие товары", "популярное сейчас".
*   **Персонализация:** Учет местоположения, времени суток, предпочтений пользователя (из User Service).
*   **Контекстные рекомендации:** Например, рекомендации для обеда/ужина, основанные на погоде.
*   **Проверка доступности:** Взаимодействие с Product Service для проверки актуальности и доступности рекомендуемых товаров.
*   **API эндпоинты (REST через Gateway):**
    *   `GET /recommendations/for-user` - Получение персонализированных рекомендаций для текущего пользователя.
    *   `GET /recommendations/popular` - Получение списка популярных товаров/ресторанов.
    *   `GET /recommendations/similar/{product_id}` - Получение товаров, похожих на указанный.

---

## 4. Нефункциональные Требования (NFR)

### 4.1. Общие NFR
*   **Язык разработки:** Основной язык для всех микросервисов – **Go**.
*   **GitHub Flow:**
    *   Две основные ветки: `main` (стабильные релизы, готовые к развертыванию) и `dev` (текущая разработка).
    *   Для каждой новой функциональности, исправления или рефакторинга создается feature-ветка от `dev`. Имя ветки должно включать ID задачи из ClickUp (например, `feature/CU-123-add-payment-method`).
    *   Pull Request (PR) создается из feature-ветки в `dev`. Название PR также должно включать ID задачи.
    *   После апрува PR и исправления всех замечаний, коммиты в feature-ветке сквошатся перед мержем в `dev`.
*   **CI/CD:**
    *   Автоматизированный CI/CD pipeline для каждого сервиса (предпочтительно GitHub Actions).
    *   Этапы: статический анализ кода (linting), модульное тестирование (unit tests), чек на уязвимости (vuln check), интеграционное тестирование (integration tests), сборка Docker-образа, сканирование образа на уязвимости, развертывание на dev/production.
    *   Сборка образов для `dev` ветки публикуется в Docker Registry с тегом `dev` или хешем коммита. Сборка с `main` – с тегом версии (например, `v1.2.3`) и `latest`.
*   **Развертывание (Deployment):**
    *   Все сервисы упаковываются в Docker-контейнеры.
    *   Оркестрация с помощью Kubernetes.
    *   Управление конфигурациями Kubernetes с помощью Helm charts.
    *   Локальная разработка и тестирование с использованием Docker Compose.
*   **Конфигурация:**
    *   Все конфигурационные параметры (адреса баз данных, ключи API, настройки Kafka и т.д.) должны передаваться через переменные окружения.
    *   Не должно быть жестко закодированных конфигураций в коде.
*   **Документация:**
    *   Каждый сервис должен иметь `README.md` с описанием, инструкциями по запуску, списком переменных окружения и примерами использования.
    *   API должны быть документированы с использованием Swagger/OpenAPI 3.0 для REST и через `.proto` файлы для gRPC. Сгенерированная документация должна быть доступна.
    *   Архитектурные диаграммы и схемы баз данных должны поддерживаться в актуальном состоянии и храниться в репозитории (`.drawio`, `.png`).
*   **Тестирование:**
    *   **Unit-тесты:** Покрытие кода unit-тестами не менее 80%.
    *   **Integration-тесты:** Тестирование взаимодействия с внешними компонентами (БД, Kafka, другие сервисы) с использованием testcontainers или моков.
    *   **API-тесты (контрактные/e2e):** Postman-коллекции с автоматизированными тестами для проверки API.
*   **Логирование:**
    *   Централизованный сбор логов (например, ELK Stack - Elasticsearch, Logstash, Kibana или AWS CloudWatch Logs).
    *   Логи должны быть структурированными (например, JSON).
    *   Каждая запись лога должна содержать как минимум: временную метку, уровень лога (INFO, WARN, ERROR, DEBUG), ID запроса (trace ID), имя сервиса, сообщение.
*   **Мониторинг и Оповещения (Alerting):**
    *   Сбор метрик с использованием Prometheus.
    *   Визуализация метрик и создание дашбордов в Grafana.
    *   Настройка оповещений (Alertmanager) для критических событий и аномалий (например, высокий процент ошибок, большое время ответа, недоступность сервиса).
*   **Безопасность:**
    *   HTTPS для всего внешнего трафика.
    *   Защита от распространенных веб-уязвимостей (OWASP Top 10).
    *   Регулярное сканирование зависимостей и Docker-образов на уязвимости.
    *   Принцип наименьших привилегий для доступа к ресурсам.
*   **Производительность:**
    *   Система должна выдерживать до 1 миллиона запросов в секунду (RPS) на ключевые сервисы (суммарно по API Gateway) с возможностью горизонтального масштабирования.
    *   Среднее время ответа для большинства API-запросов не должно превышать 200 мс (P95).
*   **Отказоустойчивость и Откат:**
    *   Использование паттерна "Outbox" для надежной доставки событий в Kafka.
    *   Реализация компенсирующих транзакций для операций, затрагивающих несколько сервисов.
    *   Механизмы retry с экспоненциальной задержкой для межсервисных вызовов.
    *   Circuit Breaker для предотвращения каскадных сбоев.
*   **Региональные ограничения:** (Если применимо) Сервис доступен только в определенных регионах (например, Республика Беларусь).
*   **Аутентификация и Авторизация:**
    *   Все API-запросы (кроме публичных, таких как регистрация/логин) должны быть защищены JWT.
    *   **JWT Стратегия:**
        *   Используются пары токенов: короткоживущий **Access Token** (например, 15-60 минут) и долгоживущий **Refresh Token** (например, 7-30 дней).
        *   Access Token подписывается Auth Service с использованием **асимметричного ключа (RSA/ES256)**. Публичный ключ доступен всем сервисам для локальной валидации.
        *   Refresh Token хранится в Auth Service (например, в Redis) и используется для получения новой пары токенов.
        *   Auth service валидируюет Access Token (подпись, срок действия, аудитория, эмитент) и далее перенапрявляет запрос к запрошенному сервису.
        *   Access Token содержит `user_id` и `roles`.
    *   Ролевая модель доступа (RBAC) реализуется на уровне каждого сервиса на основе ролей в токене.

### 4.2. NFR для каждого микросервиса

#### Auth Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** Gin (для REST API), `golang-jwt/jwt` (для работы с JWT), `crypto/rsa` (для генерации ключей).
*   **База данных:** PostgreSQL (хранение учетных данных пользователей, зашифрованных паролей, информации о ролях).
*   **Кэш:** Redis (хранение Refresh токенов, черного списка отозванных Access/Refresh токенов, сессий).
*   **API:** REST.
*   **Kafka топики (производитель):**
    *   `auth.user.signed_up` (событие о регистрации пользователя)
    *   `auth.user.logged_in` (событие о входе пользователя)
    *   `auth.user.logged_out` (событие о выходе пользователя)
    *   `auth.user.password.reset_requested`
    *   `auth.user.password.reset_completed`
*   **Тестирование:** Testify, gomock, dockertest (для PostgreSQL, Redis).
*   **Метрики Prometheus:** Количество регистраций, логинов, ошибок аутентификации, время генерации токена.

#### User (Profile) Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** Gin (для REST API), `go-playground/validator` (для валидации).
*   **База данных:** MongoDB (профили пользователей, кошельки, история транзакций кошелька, настройки).
*   **Кэш:** Redis (кэширование часто запрашиваемых профилей и балансов кошельков).
*   **API:** REST.
*   **gRPC сервисы (потребитель):** Media Service (для аватаров).
*   **Kafka топики (производитель):**
    *   `user.profile.updated`
    *   `user.wallet.created`
    *   `user.wallet.updated` (изменение баланса)
    *   `user.preferences.updated`
*   **Kafka топики (потребитель):** Order Service (для обновления истории заказов в профиле - опционально).
*   **Тестирование:** Testify, gomock, dockertest (MongoDB, Redis).
*   **Метрики Prometheus:** Количество обновлений профиля, созданных кошельков, запросов на баланс.

#### Gateway Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** Gin или Chi (для HTTP), `graphql-go/graphql` (для GraphQL), `gorilla/websocket` (для WebSocket), `grpc-ecosystem/grpc-gateway` (если используется для трансляции gRPC в REST), `golang-jwt/jwt` (для локальной валидации JWT).
*   **Кэш:** Redis (для rate limiting, кэширования ответов GraphQL - опционально).
*   **API:** REST, GraphQL, WebSocket.
*   **gRPC сервисы (клиент):** Вызывает gRPC эндпоинты всех остальных бэкенд-сервисов.
*   **Kafka топики (производитель):**
    *   `gateway.request.log` (логи доступа с метаданными запроса)
    *   `gateway.error.log` (ошибки, возникшие на Gateway)
*   **Тестирование:** Testify, httptest.
*   **Метрики Prometheus:** Количество запросов (общее и по каждому сервису), время ответа, количество ошибок (4xx, 5xx), активные WebSocket соединения.

#### Delivery Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** Gin (для REST API), `Shopify/sarama` (для Kafka).
*   **База данных:** MongoDB (заказы на доставку, статусы доставки, информация о курьерах, их текущие локации и статусы).
*   **Кэш:** Redis (кэширование статусов курьеров, активных заказов, возможно геолокаций).
*   **API:** REST.
*   **gRPC сервисы (потребитель):** Payment Service (проверка баланса), Media Service (аватары курьеров - опционально).
*   **Kafka топики (производитель):**
    *   `delivery.order.created` (если создается независимо от Order Service, иначе потребляет от Order Service)
    *   `delivery.status.updated` (событие об изменении статуса доставки)
    *   `delivery.courier.location.updated`
    *   `delivery.courier.status.updated`
*   **Kafka топики (потребитель):**
    *   `order.ready_for_delivery` (от Order Service)
    *   `provider.order.ready_for_pickup` (от Provider Service)
*   **Тестирование:** Testify, gomock, dockertest (MongoDB, Redis).
*   **Метрики Prometheus:** Количество созданных доставок, количество доставок в различных статусах, среднее время доставки, количество активных курьеров.

#### Order Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** Gin/Chi (для REST API, если есть), `Shopify/sarama` (Kafka), sqlc или GORM (для PostgreSQL).
*   **База данных:** PostgreSQL (информация о заказах, их состав, статусы, история изменений).
*   **Кэш:** Redis (кэширование статусов активных заказов).
*   **API:** REST (через Gateway), gRPC (для внутренних коммуникаций).
*   **gRPC сервисы (потребитель):** Product Service (проверка доступности товаров, цен), Payment Service (инициация оплаты), Bonus Service (применение бонусов), User Service (валидация пользователя), Delivery Service (создание доставки).
*   **Kafka топики (производитель):**
    *   `order.created`
    *   `order.status.updated` (например, `order.paid`, `order.confirmed`, `order.completed`, `order.cancelled`)
    *   `order.ready_for_delivery` (для Delivery Service)
*   **Kafka топики (потребитель):**
    *   `payment.status.updated` (от Payment Service)
    *   `delivery.status.updated` (от Delivery Service)
    *   `provider.order.status.updated` (от Provider Service, например, подтверждение заказа)
*   **Тестирование:** Testify, gomock, dockertest (PostgreSQL, Redis).
*   **Метрики Prometheus:** Количество созданных заказов, заказов в различных статусах, средняя стоимость заказа, процент отмененных заказов.

#### Payment Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** gRPC, `stripe/stripe-go` (если Stripe), `Shopify/sarama` (Kafka).
*   **База данных:** PostgreSQL (транзакции, статусы платежей, ссылки на внешние ID платежных систем).
*   **Кэш:** Redis (для идемпотентности операций, хранения временных сессий платежей).
*   **API:** gRPC.
*   **gRPC сервисы (потребитель):** Bonus Service (списание/возврат бонусов), User Service (опционально, для проверки данных пользователя).
*   **Kafka топики (производитель):**
    *   `payment.status.updated` (например, `payment.succeeded`, `payment.failed`, `payment.refunded`)
*   **Kafka топики (потребитель):**
    *   `order.created` или `order.payment_pending` (от Order Service для инициации платежа)
*   **Внешние интеграции:** Stripe API (или другой платежный шлюз).
*   **Тестирование:** Testify, gomock, dockertest (PostgreSQL, Redis), моки для Stripe API.
*   **Метрики Prometheus:** Количество успешных/неуспешных платежей, сумма транзакций, время обработки платежа.

#### Product Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** Gin/Chi (для REST API), gRPC, `olivere/elastic` (если Elasticsearch), `Shopify/sarama` (Kafka).
*   **База данных:** MongoDB или PostgreSQL (каталог продуктов, категории, цены, описания). Elasticsearch (для полнотекстового поиска и сложной фильтрации).
*   **Кэш:** Redis (кэширование популярных продуктов, результатов поиска).
*   **API:** REST (через Gateway), gRPC (для внутренних коммуникаций).
*   **gRPC сервисы (потребитель):** Media Service (для изображений продуктов).
*   **Kafka топики (производитель):**
    *   `product.created`
    *   `product.updated`
    *   `product.deleted`
    *   `product.stock.updated`
*   **Kafka топики (потребитель):**
    *   `provider.menu.item.updated` (от Provider Service для обновления информации о товарах поставщика).
*   **Тестирование:** Testify, gomock, dockertest (MongoDB/PostgreSQL, Redis, Elasticsearch).
*   **Метрики Prometheus:** Количество продуктов, запросов на поиск, среднее время ответа поиска.

#### Bonus Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** gRPC, `Shopify/sarama` (Kafka).
*   **База данных:** PostgreSQL или DynamoDB (балансы бонусов пользователей, история операций, правила начисления/списания).
*   **Кэш:** Redis (кэширование балансов пользователей для быстрого доступа).
*   **API:** gRPC.
*   **Kafka топики (производитель):**
    *   `bonus.credited` (бонусы начислены)
    *   `bonus.debited` (бонусы списаны)
    *   `bonus.expired` (бонусы сгорели)
*   **Kafka топики (потребитель):**
    *   `order.completed` (от Order Service, для начисления бонусов)
    *   `user.registered_with_promo` (от Auth/User Service, для начисления приветственных бонусов)
*   **Тестирование:** Testify, gomock, dockertest (PostgreSQL/DynamoDB, Redis).
*   **Метрики Prometheus:** Количество начисленных/списанных бонусов, общий объем активных бонусов.

#### Notification Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** `Shopify/sarama` (Kafka), `gorilla/websocket` (если отправляет через WebSocket напрямую), библиотеки для Email (например, `jordan-wright/email`), SMS (например, Twilio SDK), Push (например, Firebase SDK).
*   **База данных:** MongoDB или PostgreSQL (хранение отправленных уведомлений, статусов доставки, шаблонов уведомлений).
*   **Кэш:** Redis (очередь для повторных отправок, кэширование не доставленных уведомлений).
*   **API:** REST (через Gateway для управления историей уведомлений).
*   **gRPC сервисы (потребитель):** User Service (для получения предпочтений уведомлений).
*   **Kafka топики (потребитель):** Потребляет события от большинства других сервисов (`order.status.updated`, `payment.status.updated`, `delivery.status.updated`, `bonus.credited`, `support.ticket.updated`, `report.status.updated` и т.д.).
*   **Тестирование:** Testify, gomock, dockertest.
*   **Метрики Prometheus:** Количество отправленных уведомлений (по типам), количество ошибок доставки.

#### Support Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** Gin (для REST API), `gorilla/websocket` (для чата), `Shopify/sarama` (Kafka).
*   **База данных:** Cassandra или MongoDB (тикеты, сообщения в чатах, история обращений).
*   **Кэш:** Redis (активные сессии чатов, статусы агентов).
*   **API:** REST (через Gateway), WebSocket.
*   **gRPC сервисы (потребитель):** Media Service (для вложений), User Service (информация о пользователе), Order Service (информация о заказе).
*   **Kafka топики (производитель):**
    *   `support.ticket.created`
    *   `support.ticket.updated`
    *   `support.chat.message.sent`
*   **Kafka топики (потребитель):**
    *   `report.created` (от Report Service, для возможного создания тикета).
*   **Тестирование:** Testify, gomock, dockertest (Cassandra/MongoDB, Redis).
*   **Метрики Prometheus:** Количество созданных тикетов, среднее время ответа, количество активных чатов.

#### Media Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** gRPC, `minio/minio-go` (для S3-совместимых хранилищ).
*   **Хранилище:** AWS S3 или MinIO (для хранения файлов).
*   **База данных:** PostgreSQL или MongoDB (метаданные файлов: `media_id`, имя файла, тип, размер, `user_id`/`owner_id`, дата загрузки, ссылки на S3).
*   **Кэш:** Redis (кэширование ссылок на часто запрашиваемые файлы, возможно, хешей файлов для дедупликации).
*   **API:** gRPC (для внутренних сервисов), REST (через Gateway для загрузки клиентами).
*   **Kafka топики (производитель):**
    *   `media.file.uploaded`
    *   `media.file.deleted`
*   **Тестирование:** Testify, gomock, dockertest (PostgreSQL/MongoDB, MinIO).
*   **Метрики Prometheus:** Количество загруженных/удаленных файлов, общий объем хранимых данных, ошибки загрузки.

#### Provider Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** Gin (для REST API), gRPC, `Shopify/sarama` (Kafka).
*   **База данных:** MySQL или PostgreSQL (информация о поставщиках, их меню, зоны обслуживания, настройки).
*   **Кэш:** Redis (кэширование профилей поставщиков, меню).
*   **API:** REST (через Gateway), gRPC (для внутренних).
*   **gRPC сервисы (потребитель):** Media Service (для логотипов, фото блюд), Product Service (для синхронизации меню).
*   **Kafka топики (производитель):**
    *   `provider.created`
    *   `provider.updated`
    *   `provider.menu.item.updated`
    *   `provider.order.status.updated` (например, `provider.order.confirmed`, `provider.order.ready_for_pickup`)
*   **Kafka топики (потребитель):**
    *   `order.created_for_provider` (от Order Service).
*   **Тестирование:** Testify, gomock, dockertest (MySQL/PostgreSQL, Redis).
*   **Метрики Prometheus:** Количество поставщиков, обновлений меню, подтвержденных заказов.

#### Report Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** Gin (для REST API), `Shopify/sarama` (Kafka).
*   **База данных:** MongoDB (документы жалоб, включая метаданные, ссылки на медиа).
*   **API:** REST (через Gateway).
*   **gRPC сервисы (потребитель):** Media Service (для загрузки/связывания вложений), User Service, Order Service (для получения контекста по жалобе).
*   **Kafka топики (производитель):**
    *   `report.created`
    *   `report.status.updated`
*   **Kafka топики (потребитель):** (Если есть логика автоматического разрешения на основе событий поддержки)
    *   `support.ticket.resolved`
*   **Тестирование:** Testify, gomock, dockertest (MongoDB).
*   **Метрики Prometheus:** Количество созданных жалоб, среднее время рассмотрения.

#### Analytic Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** `Shopify/sarama` (Kafka), `ClickHouse/clickhouse-go` (для ClickHouse), gRPC.
*   **Временное хранилище событий:** AWS S3 (для сырых событий из Kafka перед загрузкой в DWH, с TTL).
*   **База данных (DWH):** ClickHouse (для хранения агрегированных данных и аналитических витрин).
*   **Инструмент ETL/ELT:** AWS Glue Job или кастомные Go-приложения для обработки данных из S3 и загрузки в ClickHouse.
*   **API:** REST (через Gateway для доступа к отчетам), gRPC (для внутренних).
*   **Kafka топики (потребитель):** Потребляет события от всех сервисов для сбора аналитики.
*   **Тестирование:** Testify, gomock, dockertest (ClickHouse), localstack (S3).
*   **Метрики Prometheus:** Объем обработанных событий, задержка обработки данных, ошибки ETL.

#### Recommender Service NFR
*   **Язык:** Go
*   **Основные библиотеки/фреймворки:** gRPC, `Shopify/sarama` (Kafka).
*   **База данных:** Elasticsearch (для хранения и поиска по индексам рекомендаций, профилям пользователей для рекомендаций) или специализированная БД для рекомендаций.
*   **Кэш:** Redis (кэширование сгенерированных рекомендаций).
*   **API:** REST (через Gateway), gRPC (для внутренних).
*   **gRPC сервисы (потребитель):** Product Service (информация о товарах), User Service (предпочтения пользователя), Analytic Service (агрегированные данные для моделей).
*   **Kafka топики (производитель):**
    *   `recommendation.generated`
    *   `recommendation.shown_to_user`
    *   `recommendation.clicked_by_user`
*   **Kafka топики (потребитель):**
    *   `analytic.user_behavior.aggregated` (от Analytic Service, для обновления моделей)
    *   `order.completed` (для корректировки пользовательских профилей)
*   **Тестирование:** Testify, gomock, dockertest (Elasticsearch, Redis).
*   **Метрики Prometheus:** Количество сгенерированных рекомендаций, CTR рекомендаций, время генерации.

---

## 5. Взаимодействие между сервисами

Микросервисы взаимодействуют друг с другом двумя основными способами:
1.  **Синхронно через gRPC:** Для запросов, требующих немедленного ответа (например, проверка доступности товара при оформлении заказа).
2.  **Асинхронно через Apache Kafka:** Для событийной архитектуры, где сервисы реагируют на изменения состояния в других частях системы (например, отправка уведомления после успешной оплаты).

Ниже представлена сводка по основным взаимодействиям (детальные топики Kafka и gRPC-вызовы указаны в NFR каждого сервиса):

*   **Auth Service:**
    *   Производит события Kafka (регистрация, вход/выход) для Analytic Service, Notification Service.
    *   Предоставляет gRPC/REST API для Gateway Service для аутентификации.
*   **User (Profile) Service:**
    *   Производит события Kafka (обновление профиля/кошелька) для Notification, Analytic Services.
    *   Предоставляет gRPC/REST API для Gateway, Order, Recommender, Support, Report Services для получения данных пользователя.
    *   Вызывает Media Service (gRPC) для управления аватарами.
*   **Gateway Service:**
    *   Принимает HTTP/GraphQL/WebSocket от клиентов.
    *   Вызывает gRPC/REST эндпоинты всех остальных сервисов.
    *   Производит события Kafka (логи запросов) для Analytic Service.
*   **Delivery Service:**
    *   Производит события Kafka (статусы доставки, локации курьеров) для Order, Notification, Analytic Services.
    *   Потребляет события Kafka (готовность заказа) от Order, Provider Services.
    *   Вызывает Payment Service (gRPC) для проверки баланса.
*   **Order Service:**
    *   Производит события Kafka (статусы заказа) для Delivery, Payment, Bonus, Notification, Analytic, User, Recommender Services.
    *   Потребляет события Kafka (статусы платежа, доставки, готовности от поставщика).
    *   Вызывает gRPC: Product, Payment, Bonus, User, Delivery Services.
*   **Payment Service:**
    *   Производит события Kafka (статусы платежа) для Order, Notification, Analytic Services.
    *   Потребляет события Kafka (инициация платежа) от Order Service.
    *   Вызывает gRPC: Bonus Service.
*   **Product Service:**
    *   Производит события Kafka (обновления продуктов/остатков) для Order, Recommender, Analytic, Notification Services.
    *   Потребляет события Kafka (обновления от поставщиков) от Provider Service.
    *   Вызывает gRPC: Media Service.
*   **Bonus Service:**
    *   Производит события Kafka (операции с бонусами) для Notification, Analytic Services.
    *   Потребляет события Kafka (завершение заказа, регистрация) от Order, Auth/User Services.
*   **Notification Service:**
    *   Потребляет события Kafka от большинства сервисов.
    *   Вызывает gRPC: User Service (для предпочтений).
    *   Интегрируется с внешними шлюзами (Email, SMS, Push).
*   **Support Service:**
    *   Производит события Kafka (тикеты, сообщения) для Notification, Analytic Services.
    *   Потребляет события Kafka (жалобы) от Report Service.
    *   Вызывает gRPC: Media, User, Order Services.
*   **Media Service:**
    *   Производит события Kafka (загрузка/удаление файлов) для Analytic, Notification Services.
*   **Provider Service:**
    *   Производит события Kafka (обновления поставщиков/меню/статусов заказов) для Product, Order, Notification, Analytic Services.
    *   Потребляет события Kafka (новые заказы) от Order Service.
    *   Вызывает gRPC: Media, Product Services.
*   **Report Service:**
    *   Производит события Kafka (создание/обновление жалоб) для Support, Notification, Analytic Services.
    *   Вызывает gRPC: Media, User, Order Services.
*   **Analytic Service:**
    *   Потребляет события Kafka от всех сервисов.
    *   Предоставляет gRPC/REST API для Recommender Service и дашбордов.
*   **Recommender Service:**
    *   Производит события Kafka (генерация/показ/клик по рекомендации) для Analytic, Notification Services.
    *   Потребляет события Kafka (агрегированное поведение, завершение заказа) от Analytic, Order Services.
    *   Вызывает gRPC: Product, User, Analytic Services.

---

## 6. Технические требования и Руководства по разработке

*   **Основной язык программирования:** Go.
*   **Стиль кода Go:** Следовать общепринятым руководствам, таким как [Effective Go](https://go.dev/doc/effective_go) и/или [Uber Go Style Guide](https://github.com/uber-go/guide/blob/master/style.md). Рекомендуется использовать `golangci-lint` с настроенным конфигурационным файлом для статического анализа.
*   **Управление зависимостями:** Go Modules. Файл `go.mod` должен быть в каждом сервисе.
*   **Межсервисное взаимодействие:**
    *   **Асинхронное:** Apache Kafka.
    *   **Синхронное:** gRPC (protobuf версии 3).
*   **API Documentation:**
    *   **REST:** OpenAPI 3.0 (Swagger). Файлы `swagger.yaml` или `swagger.json` должны генерироваться/поддерживаться для каждого сервиса, предоставляющего REST API.
    *   **gRPC:** `.proto` файлы являются источником правды.
*   **Контейнеризация:** Docker. `Dockerfile` для каждого сервиса. `docker-compose.yml` для локальной разработки.
*   **Оркестрация:** Kubernetes. Helm charts для управления развертыванием.
*   **Базы данных:** Выбор конкретной СУБД (PostgreSQL, MongoDB, Cassandra, ClickHouse, Redis, Elasticsearch, MySQL) должен быть обоснован потребностями конкретного сервиса (см. NFR каждого сервиса).
*   **Версионирование API:** Придерживаться семантического версионирования (SemVer). Для REST API версионирование через URL (например, `/v1/users`). Для gRPC – через имя пакета в `.proto` файлах.
*   **Обновление диаграмм:** Все архитектурные диаграммы, схемы баз данных и другие визуальные артефакты должны храниться в системе контроля версий (например, в папке `/docs`) в редактируемом формате (например, `.drawio`) и экспортированном (`.png`). Ответственность за их актуализацию лежит на команде.
*   **Обработка ошибок:** Стандартизированный подход к обработке и возврату ошибок в API (например, использование стандартных кодов ошибок HTTP для REST и кодов статуса gRPC).
*   **Идемпотентность:** Для критичных операций (создание заказа, платеж) должна быть обеспечена идемпотентность (например, с помощью уникального ключа идемпотентности).

